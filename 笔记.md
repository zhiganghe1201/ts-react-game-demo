# tsconfig.json

- "module": "esnext", // 模块化标准 esnext 和 es2016的区别是否允许动态导入

- noEmit： true; 不生成 `.js` 文件； 直接编译执行;




# React + JS


```ts
// 这样的定义函数组件 props下面多有children属性
export const CountComp: React.FC<IProps> =  function CountComp(props) {
	return (
		<div>
			<button onClick={() => {
				if(props.onChange) {
					props.onChange(props.num - 1)
				}
			}}>-</button>
			<span>{props.num}</span>
			<button onClick={() => {
				if(props.onChange) {
					props.onChange(props.num + 1)
				}
			}}>+</button>
		</div>
	)
}

```

### 类组件想在setState函数中获得类型检查

必须在类定义时加上类型检查

```ts

interface IState {
	num: number
}
								// 这里不加类型约束 就是空对象
class App extends React.Component<{},IState> {
	state: IState = {
		num: 0
	}

	render() {
		return (
			<CountComp n={num} onChange={(n) => {
				// 添加state约束 这样setState才会获得类型检查
				this.setState({
					num: n
				})
			}} />
		)
	}
}

```


非空断言： 在数据之后加上一个```!```,告诉TS,不用考虑该数据为空的情况；


游戏组件：提供并维护游戏中的数据， 有状态组件

